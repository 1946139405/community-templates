<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>App Elasticsearch Cluster by Zabbix agent</title>
  <link rel="stylesheet" href="/community-templates/assets/css/styles.css">
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
</head>

<body id="body">
  
  
  <a href="https://github.com/zabbix/community-templates/tree/main/Databases/Others/template_app_elasticsearch_cluster_by_zabbix_agent">
  <section class="banner-integrations">
	<div class="w container conference-header" id="training_overview" style="padding-top: 60px; min-height: 150px;">
		<div class="banner-content" style="padding-left: 0; padding-bottom: 16px;">
			<h1 class="h1 center">App Elasticsearch Cluster by Zabbix agent</h1>
		</div>
		<!-- <div class="w container">
			<div class="content text">
				<div class="grid grid-space-category center">
					
					<div class="span">
						<a class="card center category-button" href="" style="color: #25282F">category:search </a>
					</div>
					
					<div class="span">
						<a class="card center category-button" href="" style="color: #25282F">category:services </a>
					</div>
					
					<div class="span">
						<a class="card center category-button" href="" style="color: #25282F">title:Elasticsearch </a>
					</div>
					
				</div>
			</div>
		</div> -->
	</div>
</section>
  </a>
  <div class="w container">
    <h2 class="h2">Available versions</h2>
    <br>
    <div class="tabs-section">
      <div id="integrations_tabs" class="tabs">
        <ul>
          
          
          <li>
            <a class="js_tab" id="ver_5_0" href="#body">ver. 5.0
            </a>
          </li>
          
          <li>
            <a class="js_tab" id="ver_5_4" href="#body">ver. 5.4
            </a>
          </li>
          
        </ul>
      </div>
    </div>
    <br>
    <br>
              
      <div id="content_ver_5_0" class="readme">
        
        



<h1 id="app-elasticsearch-cluster-by-zabbix-agent">App Elasticsearch Cluster by Zabbix agent</h1>

<h2 id="description">Description</h2>

<p>This is the “Zabbix agent” version of the Elasticsearch template which ships with Zabbix 5.0 - Evren Yurtesen The template to monitor Elasticsearch by Zabbix that work without any external scripts. It works with both standalone and cluster instances. The metrics are collected in one pass remotely using an HTTP agent. They are getting values from REST API _cluster/health, _cluster/stats, _nodes/stats requests. You can set {$ELASTICSEARCH.USERNAME} and {$ELASTICSEARCH.PASSWORD} macros in the template for using on the host level. If you use an atypical location ES API, don’t forget to change the macros {$ELASTICSEARCH.SCHEME}, {$ELASTICSEARCH.HOST},{$ELASTICSEARCH.PORT}. You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/399473-discussion-thread-for-official-zabbix-template-for-elasticsearch Template tooling version used: 0.35</p>

<h2 id="overview">Overview</h2>

<p>This is the “Zabbix agent” version of the HTTP template shipped with Zabbix 5.0 (<a href="https://www.zabbix.com/integrations/elasticsearch">https://www.zabbix.com/integrations/elasticsearch</a>)</p>

<p>This version can connect to elasticsearch on localohost or a remote network using the zabbix agent.</p>

<p>I have added checking of read-only indices. Elasticsearch makes indices read only if there is too little disk space. Also added collection of cluster_name as an item.</p>

<p>Please report issues at GitHub (easier to track progress there!)</p>

<p>https://github.com/yurtesen/zabbix_elasticsearch</p>

<p>Evren Yurtesen</p>

<h2 id="author">Author</h2>

<p>Evren Yurtesen</p>

<h2 id="macros-used">Macros used</h2>

<p>|Name|Description|Default|Type|
|—-|———–|——-|—-|
|{$ELASTICSEARCH.FETCH_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of fetch latency in milliseconds for trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">100</code>|Text macro|
|{$ELASTICSEARCH.FLUSH_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of flush latency in milliseconds for trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">100</code>|Text macro|
|{$ELASTICSEARCH.HEAP_USED.MAX.CRIT}|&lt;p&gt;The maximum percent in the use of JVM heap for critically trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">95</code>|Text macro|
|{$ELASTICSEARCH.HEAP_USED.MAX.WARN}|&lt;p&gt;The maximum percent in the use of JVM heap for warning trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">85</code>|Text macro|
|{$ELASTICSEARCH.HOST}|&lt;p&gt;The hostname of the Elasticsearch host.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">localhost</code>|Text macro|
|{$ELASTICSEARCH.INDEXING_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of indexing latency in milliseconds for trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">100</code>|Text macro|
|{$ELASTICSEARCH.PASSWORD}|&lt;p&gt;The password of the Elasticsearch.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">|Text macro|
|{$ELASTICSEARCH.PORT}|&lt;p&gt;The port of the Elasticsearch host.&lt;/p&gt;|`9200`|Text macro|
|{$ELASTICSEARCH.QUERY_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of query latency in milliseconds for trigger expression.&lt;/p&gt;|`100`|Text macro|
|{$ELASTICSEARCH.RESPONSE_TIME.MAX.WARN}|&lt;p&gt;The ES cluster maximum response time in seconds for trigger expression.&lt;/p&gt;|`10s`|Text macro|
|{$ELASTICSEARCH.SCHEME}|&lt;p&gt;The scheme of the Elasticsearch (http/https).&lt;/p&gt;|`http`|Text macro|
|{$ELASTICSEARCH.USERNAME}|&lt;p&gt;The username of the Elasticsearch.&lt;/p&gt;|</code>|Text macro|</p>
<h2 id="template-links">Template links</h2>

<p>There are no template links in this template.</p>

<h2 id="discovery-rules">Discovery rules</h2>

<p>|Name|Description|Type|Key and additional info|
|—-|———–|—-|—-|
|Index settings discovery|&lt;p&gt;Discovery ES index settings&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.index.settings&lt;p&gt;Update: 0&lt;/p&gt;|
|Cluster nodes discovery|&lt;p&gt;Discovery ES cluster nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_nodes/_all/nodes,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1h&lt;/p&gt;|</p>
<h2 id="items-collected">Items collected</h2>

<p>|Name|Description|Type|Key and additional info|
|—-|———–|—-|—-|
|ES: Indices with shards assigned to nodes|&lt;p&gt;The total number of indices with shards assigned to the selected nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.indices.count&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of data nodes|&lt;p&gt;The number of nodes that are dedicated to data nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.number_of_data_nodes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of relocating shards|&lt;p&gt;The number of shards that are under relocation.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.relocating_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of non-deleted documents|&lt;p&gt;The total number of non-deleted documents across all primary shards assigned to the selected nodes. This number is based on the documents in Lucene segments and may include the documents from nested fields.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.indices.docs.count&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Cluster name|&lt;p&gt;Name of the cluster this node belongs to.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster_name[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Get cluster stats|&lt;p&gt;Returns cluster statistics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_cluster/stats,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Number of pending tasks|&lt;p&gt;The number of cluster-level changes that have not yet been executed.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.number_of_pending_tasks&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Nodes with the data role|&lt;p&gt;The number of selected nodes with the data role.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.count.data&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Service response time|&lt;p&gt;Checks performance of the TCP service.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|net.tcp.service.perf[”{$ELASTICSEARCH.SCHEME}”,”{$ELASTICSEARCH.HOST}”,”{$ELASTICSEARCH.PORT}”]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Number of initializing shards|&lt;p&gt;The number of shards that are under initialization.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.initializing_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of unassigned shards|&lt;p&gt;The number of shards that are not allocated.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.unassigned_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Get cluster health|&lt;p&gt;Returns the health status of a cluster.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_cluster/health?timeout=5s,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Get nodes stats|&lt;p&gt;Returns cluster nodes statistics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_nodes/stats,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Cluster uptime|&lt;p&gt;Uptime duration in seconds since JVM has last started.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.jvm.max_uptime[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Nodes with the master role|&lt;p&gt;The number of selected nodes with the master role.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.count.master&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Delayed unassigned shards|&lt;p&gt;The number of shards whose allocation has been delayed by the timeout settings.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.delayed_unassigned_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Inactive shards percentage|&lt;p&gt;The ratio of inactive shards in the cluster expressed as a percentage.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.inactive_shards_percent_as_number&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of nodes|&lt;p&gt;The number of nodes within the cluster.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.number_of_nodes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Get index settings|&lt;p&gt;Returns index settings.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_settings,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Nodes with the ingest role|&lt;p&gt;The number of selected nodes with the ingest role.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.count.ingest&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Total available size to JVM in all file stores|&lt;p&gt;The total number of bytes available to JVM in the file stores across all selected nodes. Depending on OS or process-level restrictions, this number may be less than nodes.fs.free_in_byes. This is the actual amount of free disk space the selected Elasticsearch nodes can use.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.fs.available_in_bytes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Cluster health status|&lt;p&gt;Health status of the cluster, based on the state of its primary and replica shards. Statuses are: green All shards are assigned. yellow All primary shards are assigned, but one or more replica shards are unassigned. If a node in the cluster fails, some data could be unavailable until that node is repaired. red One or more primary shards are unassigned, so some data is unavailable. This can occur briefly during cluster startup as primary shards are assigned.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.status&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Service status|&lt;p&gt;Checks if the service is running and accepting TCP connections.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|net.tcp.service[”{$ELASTICSEARCH.SCHEME}”,”{$ELASTICSEARCH.HOST}”,”{$ELASTICSEARCH.PORT}”]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Task max waiting in queue|&lt;p&gt;The time expressed in seconds since the earliest initiated task is waiting for being performed.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.task_max_waiting_in_queue&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Total size of all file stores|&lt;p&gt;The total size in bytes of all file stores across all selected nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.fs.total_in_bytes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES {#ES.INDEX_NAME}: read_only_allow_delete|&lt;p&gt;Elasticsearch enforces a read-only index block (index.blocks.read_only_allow_delete) on every index that has one or more shards allocated on the node that has at least one disk exceeding the flood stage.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.index.read_only_allow_delete[{#ES.INDEX_NAME}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Flush latency|&lt;p&gt;The average flush latency calculated from the available flush.total and flush.total_time_in_millis metrics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.flush.latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Fetch latency|&lt;p&gt;The average fetch latency calculated by sampling the total number of fetches and the total elapsed time at regular intervals.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.search.fetch_latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Indexing latency|&lt;p&gt;The average indexing latency calculated from the available index_total and index_time_in_millis metrics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.indexing.index_latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Query latency|&lt;p&gt;The average query latency calculated by sampling the total number of queries and the total elapsed time at regular intervals.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.search.query_latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total available size|&lt;p&gt;The total number of bytes available to this Java virtual machine on all file stores. Depending on OS or process level restrictions, this might appear less than fs.total.free_in_bytes. This is the actual amount of free disk space the Elasticsearch node can utilize.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.fs.total.available_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool active threads|&lt;p&gt;The number of active threads in the refresh thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.active[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent performing query|&lt;p&gt;Time in milliseconds spent performing query operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of query|&lt;p&gt;The total number of query operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Amount of JVM heap committed|&lt;p&gt;The amount of memory, in bytes, available for use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_committed_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Maximum JVM memory available for use|&lt;p&gt;The maximum amount of memory, in bytes, available for use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_max_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Amount of JVM heap currently in use|&lt;p&gt;The memory, in bytes, currently in use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_used_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Percent of JVM heap currently in use|&lt;p&gt;The percentage of memory currently in use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_used_percent[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Node uptime|&lt;p&gt;JVM uptime in seconds.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.uptime[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool tasks in queue|&lt;p&gt;The number of tasks in queue for the refresh thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.queue[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool executor tasks completed|&lt;p&gt;The number of tasks completed by the refresh thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.completed.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool executor tasks rejected|&lt;p&gt;The number of tasks rejected by the refresh thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.rejected.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool active threads|&lt;p&gt;The number of active threads in the search thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.active[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool executor tasks completed|&lt;p&gt;The number of tasks completed by the search thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.completed.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool tasks in queue|&lt;p&gt;The number of tasks in queue for the search thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.queue[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool executor tasks rejected|&lt;p&gt;The number of tasks rejected by the search thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.rejected.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool active threads|&lt;p&gt;The number of active threads in the write thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.active[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool executor tasks completed|&lt;p&gt;The number of tasks completed by the write thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.completed.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool tasks in queue|&lt;p&gt;The number of tasks in queue for the write thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.queue[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent performing query|&lt;p&gt;Time in seconds spent performing query operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of queries|&lt;p&gt;The number of query operations per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Current query operations|&lt;p&gt;The number of query operations currently running.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_current[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent throttling operations|&lt;p&gt;Time in seconds spent throttling operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.throttle_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Number of open HTTP connections|&lt;p&gt;The number of currently open HTTP connections for the node.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.http.current_open[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of HTTP connections opened|&lt;p&gt;The number of HTTP connections opened for the node per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.http.opened.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of index flushes to disk|&lt;p&gt;The total number of flush operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.flush.total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent on flushing indices to disk|&lt;p&gt;Total time in milliseconds spent performing flush operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.flush.total_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Current indexing operations|&lt;p&gt;The number of indexing operations currently running.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.index_current[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent performing indexing|&lt;p&gt;Total time in milliseconds spent performing indexing operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.index_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of indexing|&lt;p&gt;The total number of indexing operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.index_total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent throttling merge operations|&lt;p&gt;Time in seconds spent throttling merge operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.merges.total_throttled_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total size|&lt;p&gt;Total size (in bytes) of all file stores.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.fs.total.total_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent throttling recovery operations|&lt;p&gt;Time in seconds spent throttling recovery operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.recovery.throttle_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of index refreshes|&lt;p&gt;The number of refresh operations per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.refresh.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent performing refresh|&lt;p&gt;Time in seconds spent performing refresh operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.refresh.time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of fetch|&lt;p&gt;The number of fetch operations per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Current fetch operations|&lt;p&gt;The number of fetch operations currently running.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_current[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent performing fetch|&lt;p&gt;Time in seconds spent performing fetch operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent performing fetch|&lt;p&gt;Time in milliseconds spent performing fetch operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of fetch|&lt;p&gt;The total number of fetch operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool executor tasks rejected|&lt;p&gt;The number of tasks rejected by the write thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.rejected.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|</p>
<h2 id="triggers">Triggers</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
      <th>Expression</th>
      <th>Priority</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Read-only index “{#ES.INDEX_NAME}”</td>
      <td>&lt;p&gt;The index setting index.read_only_allow_delete is set to true when the index and index metadata are read only. It is set to false when ES allows writes and metadata changes. ES allows deleting the index to free up resources even when this setting is set to true.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.index.read_only_allow_delete[{#ES.INDEX_NAME}].last()}=1&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Flush latency is too high (over {$ELASTICSEARCH.FLUSH_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;If you see this metric increasing steadily, it may indicate a problem with slow disks; this problem may escalate and eventually prevent you from being able to add new information to your index.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.flush.latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Indexing latency is too high (over {$ELASTICSEARCH.INDEXING_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;If the latency is increasing, it may indicate that you are indexing too many documents at the same time (Elasticsearch’s documentation recommends starting with a bulk indexing size of 5 to 15 megabytes and increasing slowly from there).&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.indexing.index_latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Fetch latency is too high (over {$ELASTICSEARCH.FETCH_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;The fetch phase should typically take much less time than the query phase. If you notice this metric consistently increasing, this could indicate a problem with slow disks, enriching of documents (highlighting the relevant text in search results, etc.), or requesting too many results.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.search.fetch_latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Query latency is too high (over {$ELASTICSEARCH.QUERY_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;If latency exceeds a threshold, look for potential resource bottlenecks, or investigate whether you need to optimize your queries.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.search.query_latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is critical (over {$ELASTICSEARCH.HEAP_USED.MAX.CRIT}% for 1h)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.jvm.mem.heap_used_percent[{#ES.NODE}].min(1h)}&gt;95&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is high (over {$ELASTICSEARCH.HEAP_USED.MAX.WARN}% for 1h)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.jvm.mem.heap_used_percent[{#ES.NODE}].min(1h)}&gt;85&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Node {#ES.NODE} has been restarted (uptime &lt; 10m)</td>
      <td>&lt;p&gt;Uptime is less than 10 minutes&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.jvm.uptime[{#ES.NODE}].last()}&lt;10m&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>information</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Refresh thread pool executor has the rejected tasks (for 5m)</td>
      <td>&lt;p&gt;The number of tasks rejected by the refresh thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.thread_pool.refresh.rejected.rate[{#ES.NODE}].min(5m)}&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Search thread pool executor has the rejected tasks (for 5m)</td>
      <td>&lt;p&gt;The number of tasks rejected by the search thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.thread_pool.search.rejected.rate[{#ES.NODE}].min(5m)}&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Write thread pool executor has the rejected tasks (for 5m)</td>
      <td>&lt;p&gt;The number of tasks rejected by the write thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.thread_pool.write.rejected.rate[{#ES.NODE}].min(5m)}&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>Read-only index “{#ES.INDEX_NAME}” (LLD)</td>
      <td>&lt;p&gt;The index setting index.read_only_allow_delete is set to true when the index and index metadata are read only. It is set to false when ES allows writes and metadata changes. ES allows deleting the index to free up resources even when this setting is set to true.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.index.read_only_allow_delete[{#ES.INDEX_NAME}].last()}=1&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Flush latency is too high (over {$ELASTICSEARCH.FLUSH_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;If you see this metric increasing steadily, it may indicate a problem with slow disks; this problem may escalate and eventually prevent you from being able to add new information to your index.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.flush.latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Indexing latency is too high (over {$ELASTICSEARCH.INDEXING_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;If the latency is increasing, it may indicate that you are indexing too many documents at the same time (Elasticsearch’s documentation recommends starting with a bulk indexing size of 5 to 15 megabytes and increasing slowly from there).&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.indexing.index_latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Fetch latency is too high (over {$ELASTICSEARCH.FETCH_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;The fetch phase should typically take much less time than the query phase. If you notice this metric consistently increasing, this could indicate a problem with slow disks, enriching of documents (highlighting the relevant text in search results, etc.), or requesting too many results.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.search.fetch_latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Query latency is too high (over {$ELASTICSEARCH.QUERY_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;If latency exceeds a threshold, look for potential resource bottlenecks, or investigate whether you need to optimize your queries.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.indices.search.query_latency[{#ES.NODE}].min(5m)}&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is critical (over {$ELASTICSEARCH.HEAP_USED.MAX.CRIT}% for 1h) (LLD)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.jvm.mem.heap_used_percent[{#ES.NODE}].min(1h)}&gt;95&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is high (over {$ELASTICSEARCH.HEAP_USED.MAX.WARN}% for 1h) (LLD)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.jvm.mem.heap_used_percent[{#ES.NODE}].min(1h)}&gt;85&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Node {#ES.NODE} has been restarted (uptime &lt; 10m) (LLD)</td>
      <td>&lt;p&gt;Uptime is less than 10 minutes&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.jvm.uptime[{#ES.NODE}].last()}&lt;10m&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>information</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Refresh thread pool executor has the rejected tasks (for 5m) (LLD)</td>
      <td>&lt;p&gt;The number of tasks rejected by the refresh thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.thread_pool.refresh.rejected.rate[{#ES.NODE}].min(5m)}&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Search thread pool executor has the rejected tasks (for 5m) (LLD)</td>
      <td>&lt;p&gt;The number of tasks rejected by the search thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.thread_pool.search.rejected.rate[{#ES.NODE}].min(5m)}&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Write thread pool executor has the rejected tasks (for 5m) (LLD)</td>
      <td>&lt;p&gt;The number of tasks rejected by the write thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: {App Elasticsearch Cluster by Zabbix agent:es.node.thread_pool.write.rejected.rate[{#ES.NODE}].min(5m)}&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
  </tbody>
</table>


      </div>
              
      <div id="content_ver_5_4" class="readme">
        
        



<h1 id="app-elasticsearch-cluster-by-zabbix-agent">App Elasticsearch Cluster by Zabbix agent</h1>

<h2 id="description">Description</h2>

<p>This is the “Zabbix agent” version of the Elasticsearch template which ships with Zabbix 5.0 - Evren Yurtesen The template to monitor Elasticsearch by Zabbix that work without any external scripts. It works with both standalone and cluster instances. The metrics are collected in one pass remotely using an HTTP agent. They are getting values from REST API _cluster/health, _cluster/stats, _nodes/stats requests. You can set {$ELASTICSEARCH.USERNAME} and {$ELASTICSEARCH.PASSWORD} macros in the template for using on the host level. If you use an atypical location ES API, don’t forget to change the macros {$ELASTICSEARCH.SCHEME}, {$ELASTICSEARCH.HOST},{$ELASTICSEARCH.PORT}. You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/399473-discussion-thread-for-official-zabbix-template-for-elasticsearch Template tooling version used: 0.35</p>

<h2 id="overview">Overview</h2>

<p>This is the “Zabbix agent” version of the HTTP template shipped with Zabbix 5.0 (<a href="https://www.zabbix.com/integrations/elasticsearch">https://www.zabbix.com/integrations/elasticsearch</a>)</p>

<p>This version can connect to elasticsearch on localohost or a remote network using the zabbix agent.</p>

<p>I have added checking of read-only indices. Elasticsearch makes indices read only if there is too little disk space. Also added collection of cluster_name as an item.</p>

<p>Please report issues at GitHub (easier to track progress there!)</p>

<p>https://github.com/yurtesen/zabbix_elasticsearch</p>

<p>Evren Yurtesen</p>

<h2 id="author">Author</h2>

<p>Evren Yurtesen</p>

<h2 id="macros-used">Macros used</h2>

<p>|Name|Description|Default|Type|
|—-|———–|——-|—-|
|{$ELASTICSEARCH.FETCH_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of fetch latency in milliseconds for trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">100</code>|Text macro|
|{$ELASTICSEARCH.FLUSH_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of flush latency in milliseconds for trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">100</code>|Text macro|
|{$ELASTICSEARCH.HEAP_USED.MAX.CRIT}|&lt;p&gt;The maximum percent in the use of JVM heap for critically trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">95</code>|Text macro|
|{$ELASTICSEARCH.HEAP_USED.MAX.WARN}|&lt;p&gt;The maximum percent in the use of JVM heap for warning trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">85</code>|Text macro|
|{$ELASTICSEARCH.HOST}|&lt;p&gt;The hostname of the Elasticsearch host.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">localhost</code>|Text macro|
|{$ELASTICSEARCH.INDEXING_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of indexing latency in milliseconds for trigger expression.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">100</code>|Text macro|
|{$ELASTICSEARCH.PASSWORD}|&lt;p&gt;The password of the Elasticsearch.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">|Text macro|
|{$ELASTICSEARCH.PORT}|&lt;p&gt;The port of the Elasticsearch host.&lt;/p&gt;|`9200`|Text macro|
|{$ELASTICSEARCH.QUERY_LATENCY.MAX.WARN}|&lt;p&gt;Maximum of query latency in milliseconds for trigger expression.&lt;/p&gt;|`100`|Text macro|
|{$ELASTICSEARCH.RESPONSE_TIME.MAX.WARN}|&lt;p&gt;The ES cluster maximum response time in seconds for trigger expression.&lt;/p&gt;|`10s`|Text macro|
|{$ELASTICSEARCH.SCHEME}|&lt;p&gt;The scheme of the Elasticsearch (http/https).&lt;/p&gt;|`http`|Text macro|
|{$ELASTICSEARCH.USERNAME}|&lt;p&gt;The username of the Elasticsearch.&lt;/p&gt;|</code>|Text macro|</p>
<h2 id="template-links">Template links</h2>

<p>There are no template links in this template.</p>

<h2 id="discovery-rules">Discovery rules</h2>

<p>|Name|Description|Type|Key and additional info|
|—-|———–|—-|—-|
|Cluster nodes discovery|&lt;p&gt;Discovery ES cluster nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_nodes/_all/nodes,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1h&lt;/p&gt;|
|Index settings discovery|&lt;p&gt;Discovery ES index settings&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.index.settings&lt;p&gt;Update: 0&lt;/p&gt;|</p>
<h2 id="items-collected">Items collected</h2>

<p>|Name|Description|Type|Key and additional info|
|—-|———–|—-|—-|
|ES: Number of non-deleted documents|&lt;p&gt;The total number of non-deleted documents across all primary shards assigned to the selected nodes. This number is based on the documents in Lucene segments and may include the documents from nested fields.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.indices.docs.count&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Get index settings|&lt;p&gt;Returns index settings.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_settings,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Nodes with the master role|&lt;p&gt;The number of selected nodes with the master role.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.count.master&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of data nodes|&lt;p&gt;The number of nodes that are dedicated to data nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.number_of_data_nodes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Get cluster health|&lt;p&gt;Returns the health status of a cluster.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_cluster/health?timeout=5s,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Get cluster stats|&lt;p&gt;Returns cluster statistics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_cluster/stats,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Service status|&lt;p&gt;Checks if the service is running and accepting TCP connections.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|net.tcp.service[”{$ELASTICSEARCH.SCHEME}”,”{$ELASTICSEARCH.HOST}”,”{$ELASTICSEARCH.PORT}”]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Task max waiting in queue|&lt;p&gt;The time expressed in seconds since the earliest initiated task is waiting for being performed.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.task_max_waiting_in_queue&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Cluster health status|&lt;p&gt;Health status of the cluster, based on the state of its primary and replica shards. Statuses are: green All shards are assigned. yellow All primary shards are assigned, but one or more replica shards are unassigned. If a node in the cluster fails, some data could be unavailable until that node is repaired. red One or more primary shards are unassigned, so some data is unavailable. This can occur briefly during cluster startup as primary shards are assigned.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.status&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Total available size to JVM in all file stores|&lt;p&gt;The total number of bytes available to JVM in the file stores across all selected nodes. Depending on OS or process-level restrictions, this number may be less than nodes.fs.free_in_byes. This is the actual amount of free disk space the selected Elasticsearch nodes can use.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.fs.available_in_bytes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of unassigned shards|&lt;p&gt;The number of shards that are not allocated.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.unassigned_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Cluster uptime|&lt;p&gt;Uptime duration in seconds since JVM has last started.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.jvm.max_uptime[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Total size of all file stores|&lt;p&gt;The total size in bytes of all file stores across all selected nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.fs.total_in_bytes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Service response time|&lt;p&gt;Checks performance of the TCP service.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|net.tcp.service.perf[”{$ELASTICSEARCH.SCHEME}”,”{$ELASTICSEARCH.HOST}”,”{$ELASTICSEARCH.PORT}”]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Number of pending tasks|&lt;p&gt;The number of cluster-level changes that have not yet been executed.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.number_of_pending_tasks&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of nodes|&lt;p&gt;The number of nodes within the cluster.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.number_of_nodes&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Delayed unassigned shards|&lt;p&gt;The number of shards whose allocation has been delayed by the timeout settings.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.delayed_unassigned_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of relocating shards|&lt;p&gt;The number of shards that are under relocation.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.relocating_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Nodes with the ingest role|&lt;p&gt;The number of selected nodes with the ingest role.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.count.ingest&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Number of initializing shards|&lt;p&gt;The number of shards that are under initialization.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.initializing_shards&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Inactive shards percentage|&lt;p&gt;The ratio of inactive shards in the cluster expressed as a percentage.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster.inactive_shards_percent_as_number&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Indices with shards assigned to nodes|&lt;p&gt;The total number of indices with shards assigned to the selected nodes.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.indices.count&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Cluster name|&lt;p&gt;Name of the cluster this node belongs to.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.cluster_name[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;|
|ES: Get nodes stats|&lt;p&gt;Returns cluster nodes statistics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Zabbix agent</code>|web.page.get[{$ELASTICSEARCH.HOST},_nodes/stats,{$ELASTICSEARCH.PORT}]&lt;p&gt;Update: 1m&lt;/p&gt;|
|ES: Nodes with the data role|&lt;p&gt;The number of selected nodes with the data role.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.nodes.count.data&lt;p&gt;Update: 0&lt;/p&gt;|
|ES {#ES.NODE}: Flush latency|&lt;p&gt;The average flush latency calculated from the available flush.total and flush.total_time_in_millis metrics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.flush.latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Fetch latency|&lt;p&gt;The average fetch latency calculated by sampling the total number of fetches and the total elapsed time at regular intervals.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.search.fetch_latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Indexing latency|&lt;p&gt;The average indexing latency calculated from the available index_total and index_time_in_millis metrics.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.indexing.index_latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Query latency|&lt;p&gt;The average query latency calculated by sampling the total number of queries and the total elapsed time at regular intervals.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Calculated</code>|es.node.indices.search.query_latency[{#ES.NODE}]&lt;p&gt;Update: 1m&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total available size|&lt;p&gt;The total number of bytes available to this Java virtual machine on all file stores. Depending on OS or process level restrictions, this might appear less than fs.total.free_in_bytes. This is the actual amount of free disk space the Elasticsearch node can utilize.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.fs.total.available_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool active threads|&lt;p&gt;The number of active threads in the refresh thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.active[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent performing query|&lt;p&gt;Time in milliseconds spent performing query operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of query|&lt;p&gt;The total number of query operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Amount of JVM heap committed|&lt;p&gt;The amount of memory, in bytes, available for use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_committed_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Maximum JVM memory available for use|&lt;p&gt;The maximum amount of memory, in bytes, available for use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_max_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Amount of JVM heap currently in use|&lt;p&gt;The memory, in bytes, currently in use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_used_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Percent of JVM heap currently in use|&lt;p&gt;The percentage of memory currently in use by the heap.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.mem.heap_used_percent[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Node uptime|&lt;p&gt;JVM uptime in seconds.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.jvm.uptime[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool tasks in queue|&lt;p&gt;The number of tasks in queue for the refresh thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.queue[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool executor tasks completed|&lt;p&gt;The number of tasks completed by the refresh thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.completed.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Refresh thread pool executor tasks rejected|&lt;p&gt;The number of tasks rejected by the refresh thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.refresh.rejected.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool active threads|&lt;p&gt;The number of active threads in the search thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.active[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool executor tasks completed|&lt;p&gt;The number of tasks completed by the search thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.completed.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool tasks in queue|&lt;p&gt;The number of tasks in queue for the search thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.queue[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Search thread pool executor tasks rejected|&lt;p&gt;The number of tasks rejected by the search thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.search.rejected.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool active threads|&lt;p&gt;The number of active threads in the write thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.active[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool executor tasks completed|&lt;p&gt;The number of tasks completed by the write thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.completed.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool tasks in queue|&lt;p&gt;The number of tasks in queue for the write thread pool.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.queue[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent performing query|&lt;p&gt;Time in seconds spent performing query operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of queries|&lt;p&gt;The number of query operations per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Current query operations|&lt;p&gt;The number of query operations currently running.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.query_current[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent throttling operations|&lt;p&gt;Time in seconds spent throttling operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.throttle_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Number of open HTTP connections|&lt;p&gt;The number of currently open HTTP connections for the node.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.http.current_open[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of HTTP connections opened|&lt;p&gt;The number of HTTP connections opened for the node per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.http.opened.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of index flushes to disk|&lt;p&gt;The total number of flush operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.flush.total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent on flushing indices to disk|&lt;p&gt;Total time in milliseconds spent performing flush operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.flush.total_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Current indexing operations|&lt;p&gt;The number of indexing operations currently running.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.index_current[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent performing indexing|&lt;p&gt;Total time in milliseconds spent performing indexing operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.index_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of indexing|&lt;p&gt;The total number of indexing operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.indexing.index_total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent throttling merge operations|&lt;p&gt;Time in seconds spent throttling merge operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.merges.total_throttled_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total size|&lt;p&gt;Total size (in bytes) of all file stores.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.fs.total.total_in_bytes[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent throttling recovery operations|&lt;p&gt;Time in seconds spent throttling recovery operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.recovery.throttle_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of index refreshes|&lt;p&gt;The number of refresh operations per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.refresh.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent performing refresh|&lt;p&gt;Time in seconds spent performing refresh operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.refresh.time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Rate of fetch|&lt;p&gt;The number of fetch operations per second.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Current fetch operations|&lt;p&gt;The number of fetch operations currently running.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_current[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Time spent performing fetch|&lt;p&gt;Time in seconds spent performing fetch operations for the last measuring span.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_time[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total time spent performing fetch|&lt;p&gt;Time in milliseconds spent performing fetch operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_time_in_millis[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Total number of fetch|&lt;p&gt;The total number of fetch operations.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.indices.search.fetch_total[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.NODE}: Write thread pool executor tasks rejected|&lt;p&gt;The number of tasks rejected by the write thread pool executor.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.node.thread_pool.write.rejected.rate[{#ES.NODE}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|
|ES {#ES.INDEX_NAME}: read_only_allow_delete|&lt;p&gt;Elasticsearch enforces a read-only index block (index.blocks.read_only_allow_delete) on every index that has one or more shards allocated on the node that has at least one disk exceeding the flood stage.&lt;/p&gt;|<code class="language-plaintext highlighter-rouge">Dependent item</code>|es.index.read_only_allow_delete[{#ES.INDEX_NAME}]&lt;p&gt;Update: 0&lt;/p&gt;&lt;p&gt;LLD&lt;/p&gt;|</p>
<h2 id="triggers">Triggers</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
      <th>Expression</th>
      <th>Priority</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Read-only index “{#ES.INDEX_NAME}”</td>
      <td>&lt;p&gt;The index setting index.read_only_allow_delete is set to true when the index and index metadata are read only. It is set to false when ES allows writes and metadata changes. ES allows deleting the index to free up resources even when this setting is set to true.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: last(/App Elasticsearch Cluster by Zabbix agent/es.index.read_only_allow_delete[{#ES.INDEX_NAME}])=1&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Flush latency is too high (over {$ELASTICSEARCH.FLUSH_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;If you see this metric increasing steadily, it may indicate a problem with slow disks; this problem may escalate and eventually prevent you from being able to add new information to your index.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.flush.latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Indexing latency is too high (over {$ELASTICSEARCH.INDEXING_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;If the latency is increasing, it may indicate that you are indexing too many documents at the same time (Elasticsearch’s documentation recommends starting with a bulk indexing size of 5 to 15 megabytes and increasing slowly from there).&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.indexing.index_latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Fetch latency is too high (over {$ELASTICSEARCH.FETCH_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;The fetch phase should typically take much less time than the query phase. If you notice this metric consistently increasing, this could indicate a problem with slow disks, enriching of documents (highlighting the relevant text in search results, etc.), or requesting too many results.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.search.fetch_latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Query latency is too high (over {$ELASTICSEARCH.QUERY_LATENCY.MAX.WARN}ms for 5m)</td>
      <td>&lt;p&gt;If latency exceeds a threshold, look for potential resource bottlenecks, or investigate whether you need to optimize your queries.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.search.query_latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is critical (over {$ELASTICSEARCH.HEAP_USED.MAX.CRIT}% for 1h)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.jvm.mem.heap_used_percent[{#ES.NODE}],1h)&gt;95&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is high (over {$ELASTICSEARCH.HEAP_USED.MAX.WARN}% for 1h)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.jvm.mem.heap_used_percent[{#ES.NODE}],1h)&gt;85&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Node {#ES.NODE} has been restarted (uptime &lt; 10m)</td>
      <td>&lt;p&gt;Uptime is less than 10 minutes&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: last(/App Elasticsearch Cluster by Zabbix agent/es.node.jvm.uptime[{#ES.NODE}])&lt;10m&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>information</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Refresh thread pool executor has the rejected tasks (for 5m)</td>
      <td>&lt;p&gt;The number of tasks rejected by the refresh thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.thread_pool.refresh.rejected.rate[{#ES.NODE}],5m)&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Search thread pool executor has the rejected tasks (for 5m)</td>
      <td>&lt;p&gt;The number of tasks rejected by the search thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.thread_pool.search.rejected.rate[{#ES.NODE}],5m)&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Write thread pool executor has the rejected tasks (for 5m)</td>
      <td>&lt;p&gt;The number of tasks rejected by the write thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.thread_pool.write.rejected.rate[{#ES.NODE}],5m)&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Flush latency is too high (over {$ELASTICSEARCH.FLUSH_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;If you see this metric increasing steadily, it may indicate a problem with slow disks; this problem may escalate and eventually prevent you from being able to add new information to your index.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.flush.latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Indexing latency is too high (over {$ELASTICSEARCH.INDEXING_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;If the latency is increasing, it may indicate that you are indexing too many documents at the same time (Elasticsearch’s documentation recommends starting with a bulk indexing size of 5 to 15 megabytes and increasing slowly from there).&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.indexing.index_latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Fetch latency is too high (over {$ELASTICSEARCH.FETCH_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;The fetch phase should typically take much less time than the query phase. If you notice this metric consistently increasing, this could indicate a problem with slow disks, enriching of documents (highlighting the relevant text in search results, etc.), or requesting too many results.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.search.fetch_latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Query latency is too high (over {$ELASTICSEARCH.QUERY_LATENCY.MAX.WARN}ms for 5m) (LLD)</td>
      <td>&lt;p&gt;If latency exceeds a threshold, look for potential resource bottlenecks, or investigate whether you need to optimize your queries.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.indices.search.query_latency[{#ES.NODE}],5m)&gt;100&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is critical (over {$ELASTICSEARCH.HEAP_USED.MAX.CRIT}% for 1h) (LLD)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.jvm.mem.heap_used_percent[{#ES.NODE}],1h)&gt;95&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Percent of JVM heap in use is high (over {$ELASTICSEARCH.HEAP_USED.MAX.WARN}% for 1h) (LLD)</td>
      <td>&lt;p&gt;This indicates that the rate of garbage collection isn’t keeping up with the rate of garbage creation. To address this problem, you can either increase your heap size (as long as it remains below the recommended guidelines stated above), or scale out the cluster by adding more nodes.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.jvm.mem.heap_used_percent[{#ES.NODE}],1h)&gt;85&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Node {#ES.NODE} has been restarted (uptime &lt; 10m) (LLD)</td>
      <td>&lt;p&gt;Uptime is less than 10 minutes&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: last(/App Elasticsearch Cluster by Zabbix agent/es.node.jvm.uptime[{#ES.NODE}])&lt;10m&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>information</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Refresh thread pool executor has the rejected tasks (for 5m) (LLD)</td>
      <td>&lt;p&gt;The number of tasks rejected by the refresh thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.thread_pool.refresh.rejected.rate[{#ES.NODE}],5m)&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Search thread pool executor has the rejected tasks (for 5m) (LLD)</td>
      <td>&lt;p&gt;The number of tasks rejected by the search thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.thread_pool.search.rejected.rate[{#ES.NODE}],5m)&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>ES {#ES.NODE}: Write thread pool executor has the rejected tasks (for 5m) (LLD)</td>
      <td>&lt;p&gt;The number of tasks rejected by the write thread pool executor is over 0 for 5m.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: min(/App Elasticsearch Cluster by Zabbix agent/es.node.thread_pool.write.rejected.rate[{#ES.NODE}],5m)&gt;0&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>warning</td>
    </tr>
    <tr>
      <td>Read-only index “{#ES.INDEX_NAME}” (LLD)</td>
      <td>&lt;p&gt;The index setting index.read_only_allow_delete is set to true when the index and index metadata are read only. It is set to false when ES allows writes and metadata changes. ES allows deleting the index to free up resources even when this setting is set to true.&lt;/p&gt;</td>
      <td>&lt;p&gt;<strong>Expression</strong>: last(/App Elasticsearch Cluster by Zabbix agent/es.index.read_only_allow_delete[{#ES.INDEX_NAME}])=1&lt;/p&gt;&lt;p&gt;<strong>Recovery expression</strong>: &lt;/p&gt;</td>
      <td>high</td>
    </tr>
  </tbody>
</table>


      </div>
    
    <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    this.page.url = "https://zabbix.github.io/community-templates/templates/databases-others-template-app-elasticsearch-cluster-by-zabbix-agent/"; 
    this.page.identifier = "databases-others-template-app-elasticsearch-cluster-by-zabbix-agent"; 
    };
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://zabbix-github-io-community-templates.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  <script>
    (function(){  
      console.log('#content_ver_5_4');
      console.log('#ver_5_4');
      $('.readme').hide();
      $('#content_ver_5_4').fadeIn('slow');
      $('#ver_5_4').addClass('active');

                
        $('#ver_5_0').click(function() {
        $('.readme').hide();
        $('#content_ver_5_0').fadeIn('slow');
        $('.js_tab').removeClass('active')
        $('#ver_5_0').addClass('active');
        })
                
        $('#ver_5_4').click(function() {
        $('.readme').hide();
        $('#content_ver_5_4').fadeIn('slow');
        $('.js_tab').removeClass('active')
        $('#ver_5_4').addClass('active');
        })
      
    })();
</script>
</body>
</html>